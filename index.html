<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>カメラ録画 + 推論（WebGPU対応 / 自動ロード）</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --fg:#e5e7eb; --muted:#9ca3af; --accent:#38bdf8; }
    * { box-sizing: border-box; } html, body { height: 100%; }
    body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji"; background:var(--bg); color:var(--fg); }
    .wrap { max-width: 960px; margin: 0 auto; padding: 20px; }
    header { display:flex; justify-content: space-between; align-items:center; gap:12px; flex-wrap:wrap; }
    h1 { font-size: clamp(20px, 4.5vw, 28px); margin: 0; letter-spacing: .02em; }
    .hint { color: var(--muted); font-size: 13px; }
    .panel { background: var(--panel); border: 1px solid #1f2937; border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 900px){ .grid { grid-template-columns: 1.2fr .8fr; } }

    video, .recorded { width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 14px; overflow: hidden; display: block; object-fit: cover; }
    .controls { display:flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    select, button, input[type="checkbox"] { font: inherit; }
    select, button { border-radius: 12px; border: 1px solid #334155; padding: 10px 14px; background: #0b1220; color: var(--fg); }
    button { cursor: pointer; } button[disabled]{ opacity:.45; cursor:not-allowed; }
    button.primary { background: linear-gradient(180deg, #1e293b, #0b1220); border-color: #3b82f6; }
    button.danger  { border-color: #ef4444; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; border:1px solid #334155; font-size: 12px; color: var(--muted); }
    .status { font-size: 13px; color: var(--muted); }
    .blink { animation: blink 1s steps(2, start) infinite; } @keyframes blink { to { visibility: hidden; } }
    a.dl { display:inline-block; margin-top: 8px; color: white; text-decoration: none; border:1px solid #334155; border-radius: 10px; padding: 8px 12px; }
    .note { font-size: 12px; color: var(--muted); line-height: 1.5; }
    .chip { display:inline-flex; align-items:center; gap:6px; background:#0b1220; border:1px solid #334155; border-radius:999px; padding:6px 10px; font-size:12px; }
    .overlay { position:absolute; top:10px; left:10px; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; font-size:12px; }
    .stack { position:relative; }
    .backend { font-size: 12px; color: var(--muted); }
  </style>
  <!-- ONNX Runtime Web（CDN） -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>📹 カメラ録画 + 推論（WebGPU / 自動ロード）</h1>
      <div class="chip" title="接続は必ずHTTPSで">🔒 HTTPS 推奨</div>
    </header>

    <div class="grid">
      <!-- 左：プレビュー -->
      <section class="panel">
        <div class="row" style="justify-content: space-between;">
          <div class="row">
            <label for="cameraSelect" class="hint">カメラ</label>
            <select id="cameraSelect" title="使用するカメラ">
              <option value="environment">背面（環境）</option>
              <option value="user">前面（自撮り）</option>
              <option value="auto">自動</option>
            </select>
          </div>
          <div class="row">
            <label class="hint"><input type="checkbox" id="micToggle" checked /> マイクON</label>
            <label class="hint"><input type="checkbox" id="hdToggle" /> 高画質(1080pを試行)</label>
          </div>
        </div>

        <div class="stack">
          <video id="preview" playsinline muted autoplay></video>
          <div class="overlay" id="overlayInfo" style="display:none"></div>
        </div>

        <div class="controls">
          <button id="startBtn" class="primary">カメラ開始</button>
          <button id="stopBtn" class="danger" disabled>カメラ停止</button>
          <span class="pill" id="liveLabel">LIVEプレビュー</span>
          <span class="backend" id="backendLabel"></span>
        </div>
        <p class="status" id="status"></p>
      </section>

      <!-- 右：録画 + 推論 -->
      <section class="panel">
        <h3 style="margin-top:0">🎞️ 録画</h3>
        <div class="controls">
          <button id="recBtn" disabled>録画開始</button>
          <button id="stopRecBtn" class="danger" disabled>録画停止</button>
          <span class="status" id="recStatus">待機中</span>
        </div>
        <video id="playback" class="recorded" controls playsinline></video>
        <a id="download" class="dl" href="#" download style="display:none">保存する</a>
        <p class="note">
          iPhone / iPad は iOS 14.3+ で <code>MediaRecorder</code> が動作。Safari / iOS は <b>https</b> か <code>localhost</code> が必要。
        </p>

        <hr style="border-color:#334155">

        <h3 style="margin:6px 0 8px">🧠 推論（自動ロード）</h3>
        <div class="controls">
          <button id="inferStartBtn" disabled>推論開始</button>
          <button id="inferStopBtn" class="danger" disabled>推論停止</button>
          <span class="status" id="inferStatus">モデル読み込み中…</span>
        </div>
        <ul class="note" style="margin-top:8px">
          <li>読み込み先：<code>/models/multitask_web.onnx</code> / <code>/models/idx_to_cell.json</code></li>
          <li>バックエンド：WebGPU→WASMに自動フォールバック</li>
        </ul>
      </section>
    </div>

    <details style="margin-top:18px;" class="panel">
      <summary>トラブル対処のヒント</summary>
      <ul class="note">
        <li>カメラが真っ黒 → HTTPS または <code>localhost</code> で開く。</li>
        <li>自動再生されない → いずれかのボタンを押してジェスチャーを発生。</li>
        <li>WebGPU不可 → 自動で WASM にフォールバックします（速度は低下）。</li>
      </ul>
    </details>
  </div>

  <script>
    // ================== モデルの固定パス（Vercel の public/ 直配信） ==================
    const MODEL_URL = '/models/multitask_web.onnx';
    const MAP_URL   = '/models/idx_to_cell.json';

    // ================== 既存のカメラ/録画部分 ==================
    const preview = document.getElementById('preview');
    const playback = document.getElementById('playback');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recBtn = document.getElementById('recBtn');
    const stopRecBtn = document.getElementById('stopRecBtn');
    const statusEl = document.getElementById('status');
    const recStatusEl = document.getElementById('recStatus');
    const cameraSelect = document.getElementById('cameraSelect');
    const micToggle = document.getElementById('micToggle');
    const hdToggle = document.getElementById('hdToggle');
    const downloadLink = document.getElementById('download');
    const overlayInfo = document.getElementById('overlayInfo');
    const backendLabel = document.getElementById('backendLabel');

    let stream = null, recorder = null, chunks = [], chosenMime = '';

    function pickMimeType(){
      const candidates = [
        'video/mp4;codecs=h264,aac','video/mp4;codecs=avc1',
        'video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'
      ];
      for (const m of candidates){
        if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
      }
      return '';
    }
    async function startCamera(){
      try{
        stopCamera();
        const facing = cameraSelect.value, useMic = micToggle.checked, hd = hdToggle.checked;
        const videoConstraints = {
          width: hd ? {ideal:1920}:{ideal:1280}, height: hd ? {ideal:1080}:{ideal:720},
          frameRate:{ideal:30,max:60}
        };
        if (facing==='environment') videoConstraints.facingMode = {ideal:'environment'};
        else if (facing==='user')   videoConstraints.facingMode = {ideal:'user'};
        stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: useMic });
        preview.srcObject = stream; await preview.play();
        statusEl.textContent = 'カメラ起動中';
        startBtn.disabled = true; stopBtn.disabled = false; recBtn.disabled = false;
      }catch(err){
        console.error(err);
        statusEl.textContent = 'カメラ開始失敗：' + (err.message || err.name);
        startBtn.disabled=false; stopBtn.disabled=true; recBtn.disabled=true;
      }
    }
    function stopCamera(){
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
      preview.srcObject=null;
      startBtn.disabled=false; stopBtn.disabled=true; recBtn.disabled=true;
      statusEl.textContent='停止中';
    }
    function startRecording(){
      if (!stream){ alert('先にカメラを開始してください'); return; }
      chunks=[]; chosenMime = pickMimeType();
      try{ recorder = new MediaRecorder(stream, chosenMime?{mimeType:chosenMime}:undefined); }
      catch(e){ alert('録画非対応ブラウザの可能性'); return; }
      recorder.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
      recorder.onstop = handleRecordingStop;
      recorder.start();
      recBtn.disabled=true; stopRecBtn.disabled=false; recStatusEl.textContent='録画中…'; recStatusEl.classList.add('blink');
    }
    function stopRecording(){
      if (recorder && recorder.state!=='inactive') recorder.stop();
      stopRecBtn.disabled=true; recBtn.disabled=false; recStatusEl.textContent='処理中…';
    }
    function handleRecordingStop(){
      const blob = new Blob(chunks, {type: chosenMime || 'video/webm'});
      const url = URL.createObjectURL(blob);
      playback.src=url; playback.load(); playback.play();
      const ext = (chosenMime && chosenMime.includes('mp4')) ? 'mp4' : 'webm';
      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      downloadLink.href=url; downloadLink.download=`recording-${stamp}.${ext}`; downloadLink.style.display='inline-block';
      recStatusEl.textContent='録画完了'; recStatusEl.classList.remove('blink');
    }
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    recBtn.addEventListener('click', startRecording);
    stopRecBtn.addEventListener('click', stopRecording);
    [cameraSelect, micToggle, hdToggle].forEach(el=>el.addEventListener('change', ()=>{
      if (stream) statusEl.textContent='設定変更→再度「カメラ開始」を押してください。';
    }));
    preview.setAttribute('playsinline','true'); playback.setAttribute('playsinline','true');
    if (!navigator.mediaDevices?.getUserMedia){
      statusEl.textContent='このブラウザはカメラアクセス非対応です。'; startBtn.disabled=true;
    }

    // ================== 推論（ONNX Runtime Web） ==================
    const inferStartBtn = document.getElementById('inferStartBtn');
    const inferStopBtn  = document.getElementById('inferStopBtn');
    const inferStatusEl = document.getElementById('inferStatus');

    let session = null;
    let idxToCell = null;
    const IMG_H = 189, IMG_W = 252;
    const MEAN = [0.485,0.456,0.406], STD=[0.229,0.224,0.225];

    const off = document.createElement('canvas'); off.width = IMG_W; off.height = IMG_H;
    const offctx = off.getContext('2d', {willReadFrequently:true});

    async function createSessionFromUrl(url){
      let ep = 'webgpu';
      if (!('gpu' in navigator)) ep = 'wasm';
      try{
        backendLabel.textContent = `EP: ${ep}`;
        return await ort.InferenceSession.create(url, {
          executionProviders: [ep],
          graphOptimizationLevel: 'all'
        });
      }catch(e){
        console.warn('WebGPU起動失敗、WASMへフォールバックします。', e);
        backendLabel.textContent = 'EP: wasm';
        return await ort.InferenceSession.create(url, {
          executionProviders: ['wasm'],
          graphOptimizationLevel: 'all'
        });
      }
    }

    function softmax(logits){
      const max = Math.max(...logits);
      const exps = logits.map(v=>Math.exp(v - max));
      const sum = exps.reduce((a,b)=>a+b,0);
      return exps.map(v=>v/sum);
    }
    function top1(logits){
      let mi = 0, mv = -Infinity;
      for (let i=0;i<logits.length;i++){ if (logits[i] > mv){ mv = logits[i]; mi = i; } }
      return [mi, mv];
    }
    function preprocessFromVideo(video){
      offctx.drawImage(video, 0, 0, IMG_W, IMG_H);
      const im = offctx.getImageData(0, 0, IMG_W, IMG_H).data; // RGBA
      const out = new Float32Array(1*3*IMG_H*IMG_W);
      const strideC = IMG_H*IMG_W;
      for (let y=0;y<IMG_H;y++){
        for (let x=0;x<IMG_W;x++){
          const si = (y*IMG_W + x)*4;
          const r = im[si]/255, g=im[si+1]/255, b=im[si+2]/255;
          const i0 = y*IMG_W + x;
          out[i0] = (r - MEAN[0]) / STD[0];
          out[strideC + i0] = (g - MEAN[1]) / STD[1];
          out[strideC*2 + i0] = (b - MEAN[2]) / STD[2];
        }
      }
      return out;
    }

    async function autoLoadModelAndMap(){
      try{
        const resp = await fetch(MAP_URL, {cache: 'no-cache'});
        if (!resp.ok) throw new Error(`map fetch failed: ${resp.status}`);
        idxToCell = await resp.json(); // [[gx,gy], ...]

        session = await createSessionFromUrl(MODEL_URL);

        inferStatusEl.textContent = `モデル読込完了（cells=${idxToCell.length}）`;
        inferStartBtn.disabled = false;
      }catch(e){
        console.error(e);
        inferStatusEl.textContent = 'モデル読込失敗: ' + (e.message||e);
        inferStartBtn.disabled = true;
      }
    }

    let inferTimer = null;
    async function runOnce(){
      if (!session || !idxToCell || !preview.videoWidth) return;
      const input = preprocessFromVideo(preview);
      const tensor = new ort.Tensor('float32', input, [1,3,IMG_H,IMG_W]);
      const outputs = await session.run({ images: tensor });
      const vals = Object.values(outputs);
      const cell = outputs.cell_logits ?? vals[0];
      const look = outputs.look_logits ?? vals[1];

      const cellLogits = Array.from(cell.data);
      const lookLogits = Array.from(look.data);

      const [cellIdx] = top1(cellLogits);
      const [lookIdx] = top1(lookLogits);

      const [gxC, gyC] = idxToCell[cellIdx] || ['?','?'];
      const [gxL, gyL] = idxToCell[lookIdx] || ['?','?'];

      const pCell = softmax(cellLogits)[cellIdx];
      const pLook = softmax(lookLogits)[lookIdx];

      overlayInfo.style.display = 'block';
      overlayInfo.innerHTML = `
        <div><b>現在セル</b>: #${cellIdx} (gx=${gxC}, gy=${gyC})  <span class="hint">p=${pCell.toFixed(3)}</span></div>
        <div><b>向き先セル</b>: #${lookIdx} (gx=${gxL}, gy=${gyL})  <span class="hint">p=${pLook.toFixed(3)}</span></div>
      `;
    }
    function startInferLoop(){
      if (!session){ alert('モデルが読み込まれていません'); return; }
      if (!stream){ alert('先にカメラを開始してください'); return; }
      inferStatusEl.textContent = '推論中…';
      inferStartBtn.disabled = true; inferStopBtn.disabled = false;
      inferTimer = setInterval(runOnce, 100); // 約10fps
    }
    function stopInferLoop(){
      inferStartBtn.disabled = false; inferStopBtn.disabled = true;
      inferStatusEl.textContent = '停止中';
      if (inferTimer){ clearInterval(inferTimer); inferTimer=null; }
    }
    inferStartBtn.addEventListener('click', startInferLoop);
    inferStopBtn.addEventListener('click', stopInferLoop);
    stopBtn.addEventListener('click', stopInferLoop);

    // ページ読み込み時に自動ロード
    window.addEventListener('DOMContentLoaded', autoLoadModelAndMap);
  </script>
</body>
</html>
