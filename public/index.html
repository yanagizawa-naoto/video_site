<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>カメラ録画 + 推論（WebGPU対応 / 自動ロード / Top-K）</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --fg:#e5e7eb; --muted:#9ca3af; --accent:#38bdf8; }
    * { box-sizing: border-box; } html, body { height: 100%; }
    body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji"; background:var(--bg); color:var(--fg); }
    .wrap { max-width: 960px; margin: 0 auto; padding: 20px; }
    header { display:flex; justify-content: space-between; align-items:center; gap:12px; flex-wrap:wrap; }
    h1 { font-size: clamp(20px, 4.5vw, 28px); margin: 0; letter-spacing: .02em; }
    .hint { color: var(--muted); font-size: 13px; }
    .panel { background: var(--panel); border: 1px solid #1f2937; border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 900px){ .grid { grid-template-columns: 1.2fr .8fr; } }

    video, .recorded { width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 14px; overflow: hidden; display: block; object-fit: cover; }
    .controls { display:flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    select, button, input[type="checkbox"] { font: inherit; }
    select, button { border-radius: 12px; border: 1px solid #334155; padding: 10px 14px; background: #0b1220; color: var(--fg); }
    button { cursor: pointer; } button[disabled]{ opacity:.45; cursor:not-allowed; }
    button.primary { background: linear-gradient(180deg, #1e293b, #0b1220); border-color: #3b82f6; }
    button.danger  { border-color: #ef4444; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; border:1px solid #334155; font-size: 12px; color: var(--muted); }
    .status { font-size: 13px; color: var(--muted); }
    .blink { animation: blink 1s steps(2, start) infinite; } @keyframes blink { to { visibility: hidden; } }
    a.dl { display:inline-block; margin-top: 8px; color: white; text-decoration: none; border:1px solid #334155; border-radius: 10px; padding: 8px 12px; }
    .note { font-size: 12px; color: var(--muted); line-height: 1.5; }
    .chip { display:inline-flex; align-items:center; gap:6px; background:#0b1220; border:1px solid #334155; border-radius:999px; padding:6px 10px; font-size:12px; }
    .overlay { position:absolute; top:10px; left:10px; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; font-size:12px; }
    .stack { position:relative; }
    .backend { font-size: 12px; color: var(--muted); }

    /* Top-K 可視化 */
    .topk-item { display:flex; align-items:center; gap:8px; margin:6px 0; }
    .topk-label { min-width: 140px; font-size: 12px; color: var(--fg); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .prog { flex:1; height: 8px; background:#1f2937; border-radius:999px; overflow:hidden; }
    .prog > i { display:block; height:100%; width:0%; background: linear-gradient(90deg, #60a5fa, #22d3ee); }
    .topk-score { width:56px; text-align:right; font-variant-numeric: tabular-nums; color: var(--muted); font-size:12px; }
  </style>
  <!-- ONNX Runtime Web（CDN）。社内ネットでブロックされる場合はローカル同梱して src を差し替えてください。 -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>📹 カメラ録画 + 推論（WebGPU / Top-K 可視化）</h1>
      <div class="chip" title="接続は必ずHTTPSで">🔒 HTTPS 推奨</div>
    </header>

    <div class="grid">
      <!-- 左：プレビュー -->
      <section class="panel">
        <div class="row" style="justify-content: space-between;">
          <div class="row">
            <label for="cameraSelect" class="hint">カメラ</label>
            <select id="cameraSelect" title="使用するカメラ">
              <option value="environment">背面（環境）</option>
              <option value="user">前面（自撮り）</option>
              <option value="auto">自動</option>
            </select>
          </div>
          <div class="row">
            <label class="hint"><input type="checkbox" id="micToggle" checked /> マイクON</label>
            <label class="hint"><input type="checkbox" id="hdToggle" /> 高画質(1080pを試行)</label>
          </div>
        </div>

        <div class="stack">
          <video id="preview" playsinline muted autoplay></video>
          <div class="overlay" id="overlayInfo" style="display:none"></div>
        </div>

        <div class="controls">
          <button id="startBtn" class="primary">カメラ開始</button>
          <button id="stopBtn" class="danger" disabled>カメラ停止</button>
          <span class="pill" id="liveLabel">LIVEプレビュー</span>
          <span class="backend" id="backendLabel"></span>
        </div>
        <p class="status" id="status"></p>
      </section>

      <!-- 右：録画 -->
      <section class="panel">
        <h3 style="margin-top:0">🎞️ 録画</h3>
        <div class="controls">
          <button id="recBtn" disabled>録画開始</button>
          <button id="stopRecBtn" class="danger" disabled>録画停止</button>
          <span class="status" id="recStatus">待機中</span>
        </div>
        <video id="playback" class="recorded" controls playsinline></video>
        <a id="download" class="dl" href="#" download style="display:none">保存する</a>
        <p class="note">
          iPhone / iPad は iOS 14.3+ で <code>MediaRecorder</code> が動作。Safari / iOS は <b>https</b> か <code>localhost</code> が必要。
        </p>

        <hr style="border-color:#334155">

        <!-- 推論：自動ロード＆制御 -->
        <h3 style="margin:6px 0 8px">🧠 推論（自動ロード）</h3>
        <div class="controls">
          <button id="inferStartBtn" disabled>推論開始</button>
          <button id="inferStopBtn" class="danger" disabled>推論停止</button>
          <span class="status" id="inferStatus">モデル読み込み中…</span>
        </div>
        <ul class="note" style="margin-top:8px">
          <li>読み込み先：<code>/models/multitask_web.onnx</code> / <code>/models/idx_to_cell.json</code></li>
          <li>バックエンド：WebGPU→WASMに自動フォールバック</li>
        </ul>
      </section>
    </div>

    <!-- ✅ リアルタイムTop-K結果パネル -->
    <section class="panel" id="realtimePanel" style="margin-top:16px">
      <h3 style="margin:0 0 8px;">📊 リアルタイム予測</h3>
      <div class="row" style="gap:12px;margin-bottom:8px;">
        <label class="hint">Top-K
          <select id="topKSelect">
            <option>3</option><option selected>5</option><option>10</option>
          </select>
        </label>
        <label class="hint"><input type="checkbox" id="smoothToggle" checked> スムージング(EMA)</label>
        <span class="pill" id="fpsLabel">FPS: --</span>
      </div>
      <div class="grid" style="grid-template-columns: 1fr 1fr; gap:14px">
        <div>
          <div class="hint" style="margin-bottom:6px">現在セル（cell head）</div>
          <div id="topkCell"></div>
        </div>
        <div>
          <div class="hint" style="margin-bottom:6px">向き先セル（look head）</div>
          <div id="topkLook"></div>
        </div>
      </div>
    </section>

    <details style="margin-top:18px;" class="panel">
      <summary>トラブル対処のヒント</summary>
      <ul class="note">
        <li>トップが 404 → Vercel の Output Directory を見直し（<code>public</code> 推奨）。</li>
        <li>モデル 404 → <code>public/models/...</code> に配置＆パスは <code>/models/...</code>。</li>
        <li>WebGPU不可 → 自動で WASM にフォールバック（速度は低下）。</li>
        <li>自動再生されない → いずれかのボタンを押してジェスチャーを発生。</li>
      </ul>
    </details>
  </div>

  <script>
    // ================== モデルの固定パス（Vercel public/ 直配信） ==================
    const MODEL_URL = '/models/multitask_web.onnx';
    const MAP_URL   = '/models/idx_to_cell.json';

    // ================== 既存のカメラ/録画部分 ==================
    const preview = document.getElementById('preview');
    const playback = document.getElementById('playback');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recBtn = document.getElementById('recBtn');
    const stopRecBtn = document.getElementById('stopRecBtn');
    const statusEl = document.getElementById('status');
    const recStatusEl = document.getElementById('recStatus');
    const cameraSelect = document.getElementById('cameraSelect');
    const micToggle = document.getElementById('micToggle');
    const hdToggle = document.getElementById('hdToggle');
    const downloadLink = document.getElementById('download');
    const overlayInfo = document.getElementById('overlayInfo');
    const backendLabel = document.getElementById('backendLabel');

    let stream = null, recorder = null, chunks = [], chosenMime = '';

    function pickMimeType(){
      const candidates = [
        'video/mp4;codecs=h264,aac','video/mp4;codecs=avc1',
        'video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'
      ];
      for (const m of candidates){
        if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
      }
      return '';
    }
    async function startCamera(){
      try{
        stopCamera();
        const facing = cameraSelect.value, useMic = micToggle.checked, hd = hdToggle.checked;
        const videoConstraints = {
          width: hd ? {ideal:1920}:{ideal:1280}, height: hd ? {ideal:1080}:{ideal:720},
          frameRate:{ideal:30,max:60}
        };
        if (facing==='environment') videoConstraints.facingMode = {ideal:'environment'};
        else if (facing==='user')   videoConstraints.facingMode = {ideal:'user'};
        stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: useMic });
        preview.srcObject = stream; await preview.play();
        statusEl.textContent = 'カメラ起動中';
        startBtn.disabled = true; stopBtn.disabled = false; recBtn.disabled = false;
      }catch(err){
        console.error(err);
        statusEl.textContent = 'カメラ開始失敗：' + (err.message || err.name);
        startBtn.disabled=false; stopBtn.disabled=true; recBtn.disabled=true;
      }
    }
    function stopCamera(){
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
      preview.srcObject=null;
      startBtn.disabled=false; stopBtn.disabled=true; recBtn.disabled=true;
      statusEl.textContent='停止中';
    }
    function startRecording(){
      if (!stream){ alert('先にカメラを開始してください'); return; }
      chunks=[]; chosenMime = pickMimeType();
      try{ recorder = new MediaRecorder(stream, chosenMime?{mimeType:chosenMime}:undefined); }
      catch(e){ alert('録画非対応ブラウザの可能性'); return; }
      recorder.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
      recorder.onstop = handleRecordingStop;
      recorder.start();
      recBtn.disabled=true; stopRecBtn.disabled=false; recStatusEl.textContent='録画中…'; recStatusEl.classList.add('blink');
    }
    function stopRecording(){
      if (recorder && recorder.state!=='inactive') recorder.stop();
      stopRecBtn.disabled=true; recBtn.disabled=false; recStatusEl.textContent='処理中…';
    }
    function handleRecordingStop(){
      const blob = new Blob(chunks, {type: chosenMime || 'video/webm'});
      const url = URL.createObjectURL(blob);
      playback.src=url; playback.load(); playback.play();
      const ext = (chosenMime && chosenMime.includes('mp4')) ? 'mp4' : 'webm';
      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      downloadLink.href=url; downloadLink.download=`recording-${stamp}.${ext}`; downloadLink.style.display='inline-block';
      recStatusEl.textContent='録画完了'; recStatusEl.classList.remove('blink');
    }
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    recBtn.addEventListener('click', startRecording);
    stopRecBtn.addEventListener('click', stopRecording);
    [cameraSelect, micToggle, hdToggle].forEach(el=>el.addEventListener('change', ()=>{
      if (stream) statusEl.textContent='設定変更→再度「カメラ開始」を押してください。';
    }));
    preview.setAttribute('playsinline','true'); playback.setAttribute('playsinline','true');
    if (!navigator.mediaDevices?.getUserMedia){
      statusEl.textContent='このブラウザはカメラアクセス非対応です。'; startBtn.disabled=true;
    }

    // ================== 推論（ONNX Runtime Web） ==================
    const inferStartBtn = document.getElementById('inferStartBtn');
    const inferStopBtn  = document.getElementById('inferStopBtn');
    const inferStatusEl = document.getElementById('inferStatus');

    let session = null;
    let idxToCell = null;
    const IMG_H = 189, IMG_W = 252;
    const MEAN = [0.485,0.456,0.406], STD=[0.229,0.224,0.225];

    const off = document.createElement('canvas'); off.width = IMG_W; off.height = IMG_H;
    const offctx = off.getContext('2d', {willReadFrequently:true});

    async function createSessionFromUrl(url){
      let ep = 'webgpu';
      if (!('gpu' in navigator)) ep = 'wasm';
      try{
        backendLabel.textContent = `EP: ${ep}`;
        return await ort.InferenceSession.create(url, {
          executionProviders: [ep],
          graphOptimizationLevel: 'all'
        });
      }catch(e){
        console.warn('WebGPU起動失敗、WASMへフォールバックします。', e);
        backendLabel.textContent = 'EP: wasm';
        return await ort.InferenceSession.create(url, {
          executionProviders: ['wasm'],
          graphOptimizationLevel: 'all'
        });
      }
    }

    // ---------- 可視化ユーティリティ ----------
    function softmax(logits){
      const max = Math.max(...logits);
      const exps = logits.map(v=>Math.exp(v - max));
      const sum = exps.reduce((a,b)=>a+b,0);
      return exps.map(v=>v/sum);
    }
    // Top-K（logit配列から上位Kの index を返し、最後に確率化）
    function topkProbs(logits, k){
      const idx = [...logits.keys()].sort((a,b)=> logits[b]-logits[a]).slice(0, k);
      const max = Math.max(...idx.map(i=>logits[i]));
      const exps = idx.map(i => Math.exp(logits[i]-max));
      const sum = exps.reduce((a,b)=>a+b,0);
      return idx.map((i, t)=> ({i, p: exps[t]/sum}));
    }
    function renderTopK(containerEl, items, labelFromIndex){
      containerEl.innerHTML = '';
      for (const {i, p} of items){
        const wrap = document.createElement('div'); wrap.className = 'topk-item';
        const lb = document.createElement('div'); lb.className='topk-label';
        lb.textContent = `${labelFromIndex(i)}`;
        const prog = document.createElement('div'); prog.className='prog';
        const bar = document.createElement('i'); bar.style.width = `${(p*100).toFixed(1)}%`;
        prog.appendChild(bar);
        const sc = document.createElement('div'); sc.className='topk-score'; sc.textContent = (p*100).toFixed(1)+'%';
        wrap.append(lb, prog, sc);
        containerEl.appendChild(wrap);
      }
    }

    // ---------- スムージング & FPS ----------
    let emaCell = null, emaLook = null;
    const EMA_ALPHA = 0.6; // 0.3～0.8で調整可
    let lastT = performance.now(), fpsAccum = 0, fpsCount = 0;
    const fpsLabel = document.getElementById('fpsLabel');
    const topKSelect = document.getElementById('topKSelect');
    const smoothToggle = document.getElementById('smoothToggle');
    const topkCellEl = document.getElementById('topkCell');
    const topkLookEl = document.getElementById('topkLook');

    function labelFromIndex(i){
      const [gx, gy] = idxToCell[i] || ['?','?'];
      return `#${i} (gx=${gx}, gy=${gy})`;
    }

    function preprocessFromVideo(video){
      offctx.drawImage(video, 0, 0, IMG_W, IMG_H);
      const im = offctx.getImageData(0, 0, IMG_W, IMG_H).data; // RGBA
      const out = new Float32Array(1*3*IMG_H*IMG_W);
      const strideC = IMG_H*IMG_W;
      for (let y=0;y<IMG_H;y++){
        for (let x=0;x<IMG_W;x++){
          const si = (y*IMG_W + x)*4;
          const r = im[si]/255, g=im[si+1]/255, b=im[si+2]/255;
          const i0 = y*IMG_W + x;
          out[i0] = (r - MEAN[0]) / STD[0];
          out[strideC + i0] = (g - MEAN[1]) / STD[1];
          out[strideC*2 + i0] = (b - MEAN[2]) / STD[2];
        }
      }
      return out;
    }

    async function autoLoadModelAndMap(){
      try{
        const resp = await fetch(MAP_URL, {cache: 'no-cache'});
        if (!resp.ok) throw new Error(`map fetch failed: ${resp.status}`);
        idxToCell = await resp.json(); // [[gx,gy], ...]

        session = await createSessionFromUrl(MODEL_URL);

        inferStatusEl.textContent = `モデル読込完了（cells=${idxToCell.length}）`;
        inferStartBtn.disabled = false;
      }catch(e){
        console.error(e);
        inferStatusEl.textContent = 'モデル読込失敗: ' + (e.message||e);
        inferStartBtn.disabled = true;
      }
    }

    let inferTimer = null;
    async function runOnce(){
      if (!session || !idxToCell || !preview.videoWidth) return;

      // FPS
      const now = performance.now();
      const dt = now - lastT; lastT = now;
      const instFPS = 1000 / Math.max(1, dt);
      fpsAccum += instFPS; fpsCount++;
      if (fpsCount >= 10){
        fpsLabel.textContent = 'FPS: ' + (fpsAccum/fpsCount).toFixed(1);
        fpsAccum = 0; fpsCount = 0;
      }

      // 入力
      const input = preprocessFromVideo(preview);
      const tensor = new ort.Tensor('float32', input, [1,3,IMG_H,IMG_W]);

      // 推論
      const outputs = await session.run({ images: tensor });
      const vals = Object.values(outputs);
      const cell = outputs.cell_logits ?? vals[0];
      const look = outputs.look_logits ?? vals[1];

      // ロジット→確率（全クラス）
      function toProbs(logits){
        const max = Math.max(...logits);
        const exps = logits.map(v=>Math.exp(v-max));
        const sum = exps.reduce((a,b)=>a+b,0);
        return exps.map(v=>v/sum);
      }
      let pCell = toProbs(Array.from(cell.data));
      let pLook = toProbs(Array.from(look.data));

      // スムージング
      if (smoothToggle.checked){
        if (!emaCell) emaCell = pCell.slice();
        if (!emaLook) emaLook = pLook.slice();
        for (let i=0;i<pCell.length;i++){
          emaCell[i] = EMA_ALPHA*pCell[i] + (1-EMA_ALPHA)*emaCell[i];
          emaLook[i] = EMA_ALPHA*pLook[i] + (1-EMA_ALPHA)*emaLook[i];
        }
        pCell = emaCell; pLook = emaLook;
      }

      // Top-K
      const K = parseInt(topKSelect.value || '5', 10);
      const idxC = [...pCell.keys()].sort((a,b)=> pCell[b]-pCell[a]).slice(0, K).map(i=>({i, p:pCell[i]}));
      const idxL = [...pLook.keys()].sort((a,b)=> pLook[b]-pLook[a]).slice(0, K).map(i=>({i, p:pLook[i]}));

      // 描画（Top-K）
      renderTopK(topkCellEl, idxC, labelFromIndex);
      renderTopK(topkLookEl, idxL, labelFromIndex);

      // オーバレイ（Top1の簡易表示）
      const bestC = idxC[0], bestL = idxL[0];
      overlayInfo.style.display = 'block';
      overlayInfo.innerHTML = `
        <div><b>現在セル</b>: ${labelFromIndex(bestC.i)} <span class="hint">p=${bestC.p.toFixed(3)}</span></div>
        <div><b>向き先セル</b>: ${labelFromIndex(bestL.i)} <span class="hint">p=${bestL.p.toFixed(3)}</span></div>
      `;
    }

    function startInferLoop(){
      if (!session){ alert('モデルが読み込まれていません'); return; }
      if (!stream){ alert('先にカメラを開始してください'); return; }
      inferStatusEl.textContent = '推論中…';
      inferStartBtn.disabled = true; inferStopBtn.disabled = false;
      // 約 ~10fps（必要なら 50–150ms で調整）
      inferTimer = setInterval(runOnce, 100);
    }
    function stopInferLoop(){
      inferStartBtn.disabled = false; inferStopBtn.disabled = true;
      inferStatusEl.textContent = '停止中';
      if (inferTimer){ clearInterval(inferTimer); inferTimer=null; }
    }

    inferStartBtn.addEventListener('click', startInferLoop);
    inferStopBtn.addEventListener('click', stopInferLoop);
    stopBtn.addEventListener('click', stopInferLoop);

    // ページ読み込み時に自動ロード
    window.addEventListener('DOMContentLoaded', autoLoadModelAndMap);
  </script>
</body>
</html>
