<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚«ãƒ¡ãƒ©éŒ²ç”» + æ¨è«–ï¼ˆWebGPUå¯¾å¿œ / è‡ªå‹•ãƒ­ãƒ¼ãƒ‰ï¼‰</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --fg:#e5e7eb; --muted:#9ca3af; --accent:#38bdf8; }
    * { box-sizing: border-box; } html, body { height: 100%; }
    body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji"; background:var(--bg); color:var(--fg); }
    .wrap { max-width: 960px; margin: 0 auto; padding: 20px; }
    header { display:flex; justify-content: space-between; align-items:center; gap:12px; flex-wrap:wrap; }
    h1 { font-size: clamp(20px, 4.5vw, 28px); margin: 0; letter-spacing: .02em; }
    .hint { color: var(--muted); font-size: 13px; }
    .panel { background: var(--panel); border: 1px solid #1f2937; border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 900px){ .grid { grid-template-columns: 1.2fr .8fr; } }

    video, .recorded { width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 14px; overflow: hidden; display: block; object-fit: cover; }
    .controls { display:flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    select, button, input[type="checkbox"] { font: inherit; }
    select, button { border-radius: 12px; border: 1px solid #334155; padding: 10px 14px; background: #0b1220; color: var(--fg); }
    button { cursor: pointer; } button[disabled]{ opacity:.45; cursor:not-allowed; }
    button.primary { background: linear-gradient(180deg, #1e293b, #0b1220); border-color: #3b82f6; }
    button.danger  { border-color: #ef4444; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; border:1px solid #334155; font-size: 12px; color: var(--muted); }
    .status { font-size: 13px; color: var(--muted); }
    .blink { animation: blink 1s steps(2, start) infinite; } @keyframes blink { to { visibility: hidden; } }
    a.dl { display:inline-block; margin-top: 8px; color: white; text-decoration: none; border:1px solid #334155; border-radius: 10px; padding: 8px 12px; }
    .note { font-size: 12px; color: var(--muted); line-height: 1.5; }
    .chip { display:inline-flex; align-items:center; gap:6px; background:#0b1220; border:1px solid #334155; border-radius:999px; padding:6px 10px; font-size:12px; }
    .overlay { position:absolute; top:10px; left:10px; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; font-size:12px; }
    .stack { position:relative; }
    .backend { font-size: 12px; color: var(--muted); }
  </style>
  <!-- ONNX Runtime Webï¼ˆCDNï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ğŸ“¹ ã‚«ãƒ¡ãƒ©éŒ²ç”» + æ¨è«–ï¼ˆWebGPU / è‡ªå‹•ãƒ­ãƒ¼ãƒ‰ï¼‰</h1>
      <div class="chip" title="æ¥ç¶šã¯å¿…ãšHTTPSã§">ğŸ”’ HTTPS æ¨å¥¨</div>
    </header>

    <div class="grid">
      <!-- å·¦ï¼šãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
      <section class="panel">
        <div class="row" style="justify-content: space-between;">
          <div class="row">
            <label for="cameraSelect" class="hint">ã‚«ãƒ¡ãƒ©</label>
            <select id="cameraSelect" title="ä½¿ç”¨ã™ã‚‹ã‚«ãƒ¡ãƒ©">
              <option value="environment">èƒŒé¢ï¼ˆç’°å¢ƒï¼‰</option>
              <option value="user">å‰é¢ï¼ˆè‡ªæ’®ã‚Šï¼‰</option>
              <option value="auto">è‡ªå‹•</option>
            </select>
          </div>
          <div class="row">
            <label class="hint"><input type="checkbox" id="micToggle" checked /> ãƒã‚¤ã‚¯ON</label>
            <label class="hint"><input type="checkbox" id="hdToggle" /> é«˜ç”»è³ª(1080pã‚’è©¦è¡Œ)</label>
          </div>
        </div>

        <div class="stack">
          <video id="preview" playsinline muted autoplay></video>
          <div class="overlay" id="overlayInfo" style="display:none"></div>
        </div>

        <div class="controls">
          <button id="startBtn" class="primary">ã‚«ãƒ¡ãƒ©é–‹å§‹</button>
          <button id="stopBtn" class="danger" disabled>ã‚«ãƒ¡ãƒ©åœæ­¢</button>
          <span class="pill" id="liveLabel">LIVEãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</span>
          <span class="backend" id="backendLabel"></span>
        </div>
        <p class="status" id="status"></p>
      </section>

      <!-- å³ï¼šéŒ²ç”» + æ¨è«– -->
      <section class="panel">
        <h3 style="margin-top:0">ğŸï¸ éŒ²ç”»</h3>
        <div class="controls">
          <button id="recBtn" disabled>éŒ²ç”»é–‹å§‹</button>
          <button id="stopRecBtn" class="danger" disabled>éŒ²ç”»åœæ­¢</button>
          <span class="status" id="recStatus">å¾…æ©Ÿä¸­</span>
        </div>
        <video id="playback" class="recorded" controls playsinline></video>
        <a id="download" class="dl" href="#" download style="display:none">ä¿å­˜ã™ã‚‹</a>
        <p class="note">
          iPhone / iPad ã¯ iOS 14.3+ ã§ <code>MediaRecorder</code> ãŒå‹•ä½œã€‚Safari / iOS ã¯ <b>https</b> ã‹ <code>localhost</code> ãŒå¿…è¦ã€‚
        </p>

        <hr style="border-color:#334155">

        <h3 style="margin:6px 0 8px">ğŸ§  æ¨è«–ï¼ˆè‡ªå‹•ãƒ­ãƒ¼ãƒ‰ï¼‰</h3>
        <div class="controls">
          <button id="inferStartBtn" disabled>æ¨è«–é–‹å§‹</button>
          <button id="inferStopBtn" class="danger" disabled>æ¨è«–åœæ­¢</button>
          <span class="status" id="inferStatus">ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­â€¦</span>
        </div>
        <ul class="note" style="margin-top:8px">
          <li>èª­ã¿è¾¼ã¿å…ˆï¼š<code>/models/multitask_web.onnx</code> / <code>/models/idx_to_cell.json</code></li>
          <li>ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼šWebGPUâ†’WASMã«è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯</li>
        </ul>
      </section>
    </div>

    <details style="margin-top:18px;" class="panel">
      <summary>ãƒˆãƒ©ãƒ–ãƒ«å¯¾å‡¦ã®ãƒ’ãƒ³ãƒˆ</summary>
      <ul class="note">
        <li>ã‚«ãƒ¡ãƒ©ãŒçœŸã£é»’ â†’ HTTPS ã¾ãŸã¯ <code>localhost</code> ã§é–‹ãã€‚</li>
        <li>è‡ªå‹•å†ç”Ÿã•ã‚Œãªã„ â†’ ã„ãšã‚Œã‹ã®ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚’ç™ºç”Ÿã€‚</li>
        <li>WebGPUä¸å¯ â†’ è‡ªå‹•ã§ WASM ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ï¼ˆé€Ÿåº¦ã¯ä½ä¸‹ï¼‰ã€‚</li>
      </ul>
    </details>
  </div>

  <script>
    // ================== ãƒ¢ãƒ‡ãƒ«ã®å›ºå®šãƒ‘ã‚¹ï¼ˆVercel ã® public/ ç›´é…ä¿¡ï¼‰ ==================
    const MODEL_URL = '/models/multitask_web.onnx';
    const MAP_URL   = '/models/idx_to_cell.json';

    // ================== æ—¢å­˜ã®ã‚«ãƒ¡ãƒ©/éŒ²ç”»éƒ¨åˆ† ==================
    const preview = document.getElementById('preview');
    const playback = document.getElementById('playback');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recBtn = document.getElementById('recBtn');
    const stopRecBtn = document.getElementById('stopRecBtn');
    const statusEl = document.getElementById('status');
    const recStatusEl = document.getElementById('recStatus');
    const cameraSelect = document.getElementById('cameraSelect');
    const micToggle = document.getElementById('micToggle');
    const hdToggle = document.getElementById('hdToggle');
    const downloadLink = document.getElementById('download');
    const overlayInfo = document.getElementById('overlayInfo');
    const backendLabel = document.getElementById('backendLabel');

    let stream = null, recorder = null, chunks = [], chosenMime = '';

    function pickMimeType(){
      const candidates = [
        'video/mp4;codecs=h264,aac','video/mp4;codecs=avc1',
        'video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'
      ];
      for (const m of candidates){
        if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
      }
      return '';
    }
    async function startCamera(){
      try{
        stopCamera();
        const facing = cameraSelect.value, useMic = micToggle.checked, hd = hdToggle.checked;
        const videoConstraints = {
          width: hd ? {ideal:1920}:{ideal:1280}, height: hd ? {ideal:1080}:{ideal:720},
          frameRate:{ideal:30,max:60}
        };
        if (facing==='environment') videoConstraints.facingMode = {ideal:'environment'};
        else if (facing==='user')   videoConstraints.facingMode = {ideal:'user'};
        stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: useMic });
        preview.srcObject = stream; await preview.play();
        statusEl.textContent = 'ã‚«ãƒ¡ãƒ©èµ·å‹•ä¸­';
        startBtn.disabled = true; stopBtn.disabled = false; recBtn.disabled = false;
      }catch(err){
        console.error(err);
        statusEl.textContent = 'ã‚«ãƒ¡ãƒ©é–‹å§‹å¤±æ•—ï¼š' + (err.message || err.name);
        startBtn.disabled=false; stopBtn.disabled=true; recBtn.disabled=true;
      }
    }
    function stopCamera(){
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
      preview.srcObject=null;
      startBtn.disabled=false; stopBtn.disabled=true; recBtn.disabled=true;
      statusEl.textContent='åœæ­¢ä¸­';
    }
    function startRecording(){
      if (!stream){ alert('å…ˆã«ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„'); return; }
      chunks=[]; chosenMime = pickMimeType();
      try{ recorder = new MediaRecorder(stream, chosenMime?{mimeType:chosenMime}:undefined); }
      catch(e){ alert('éŒ²ç”»éå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã®å¯èƒ½æ€§'); return; }
      recorder.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
      recorder.onstop = handleRecordingStop;
      recorder.start();
      recBtn.disabled=true; stopRecBtn.disabled=false; recStatusEl.textContent='éŒ²ç”»ä¸­â€¦'; recStatusEl.classList.add('blink');
    }
    function stopRecording(){
      if (recorder && recorder.state!=='inactive') recorder.stop();
      stopRecBtn.disabled=true; recBtn.disabled=false; recStatusEl.textContent='å‡¦ç†ä¸­â€¦';
    }
    function handleRecordingStop(){
      const blob = new Blob(chunks, {type: chosenMime || 'video/webm'});
      const url = URL.createObjectURL(blob);
      playback.src=url; playback.load(); playback.play();
      const ext = (chosenMime && chosenMime.includes('mp4')) ? 'mp4' : 'webm';
      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      downloadLink.href=url; downloadLink.download=`recording-${stamp}.${ext}`; downloadLink.style.display='inline-block';
      recStatusEl.textContent='éŒ²ç”»å®Œäº†'; recStatusEl.classList.remove('blink');
    }
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    recBtn.addEventListener('click', startRecording);
    stopRecBtn.addEventListener('click', stopRecording);
    [cameraSelect, micToggle, hdToggle].forEach(el=>el.addEventListener('change', ()=>{
      if (stream) statusEl.textContent='è¨­å®šå¤‰æ›´â†’å†åº¦ã€Œã‚«ãƒ¡ãƒ©é–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚';
    }));
    preview.setAttribute('playsinline','true'); playback.setAttribute('playsinline','true');
    if (!navigator.mediaDevices?.getUserMedia){
      statusEl.textContent='ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹éå¯¾å¿œã§ã™ã€‚'; startBtn.disabled=true;
    }

    // ================== æ¨è«–ï¼ˆONNX Runtime Webï¼‰ ==================
    const inferStartBtn = document.getElementById('inferStartBtn');
    const inferStopBtn  = document.getElementById('inferStopBtn');
    const inferStatusEl = document.getElementById('inferStatus');

    let session = null;
    let idxToCell = null;
    const IMG_H = 189, IMG_W = 252;
    const MEAN = [0.485,0.456,0.406], STD=[0.229,0.224,0.225];

    const off = document.createElement('canvas'); off.width = IMG_W; off.height = IMG_H;
    const offctx = off.getContext('2d', {willReadFrequently:true});

    async function createSessionFromUrl(url){
      let ep = 'webgpu';
      if (!('gpu' in navigator)) ep = 'wasm';
      try{
        backendLabel.textContent = `EP: ${ep}`;
        return await ort.InferenceSession.create(url, {
          executionProviders: [ep],
          graphOptimizationLevel: 'all'
        });
      }catch(e){
        console.warn('WebGPUèµ·å‹•å¤±æ•—ã€WASMã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚', e);
        backendLabel.textContent = 'EP: wasm';
        return await ort.InferenceSession.create(url, {
          executionProviders: ['wasm'],
          graphOptimizationLevel: 'all'
        });
      }
    }

    function softmax(logits){
      const max = Math.max(...logits);
      const exps = logits.map(v=>Math.exp(v - max));
      const sum = exps.reduce((a,b)=>a+b,0);
      return exps.map(v=>v/sum);
    }
    function top1(logits){
      let mi = 0, mv = -Infinity;
      for (let i=0;i<logits.length;i++){ if (logits[i] > mv){ mv = logits[i]; mi = i; } }
      return [mi, mv];
    }
    function preprocessFromVideo(video){
      offctx.drawImage(video, 0, 0, IMG_W, IMG_H);
      const im = offctx.getImageData(0, 0, IMG_W, IMG_H).data; // RGBA
      const out = new Float32Array(1*3*IMG_H*IMG_W);
      const strideC = IMG_H*IMG_W;
      for (let y=0;y<IMG_H;y++){
        for (let x=0;x<IMG_W;x++){
          const si = (y*IMG_W + x)*4;
          const r = im[si]/255, g=im[si+1]/255, b=im[si+2]/255;
          const i0 = y*IMG_W + x;
          out[i0] = (r - MEAN[0]) / STD[0];
          out[strideC + i0] = (g - MEAN[1]) / STD[1];
          out[strideC*2 + i0] = (b - MEAN[2]) / STD[2];
        }
      }
      return out;
    }

    async function autoLoadModelAndMap(){
      try{
        const resp = await fetch(MAP_URL, {cache: 'no-cache'});
        if (!resp.ok) throw new Error(`map fetch failed: ${resp.status}`);
        idxToCell = await resp.json(); // [[gx,gy], ...]

        session = await createSessionFromUrl(MODEL_URL);

        inferStatusEl.textContent = `ãƒ¢ãƒ‡ãƒ«èª­è¾¼å®Œäº†ï¼ˆcells=${idxToCell.length}ï¼‰`;
        inferStartBtn.disabled = false;
      }catch(e){
        console.error(e);
        inferStatusEl.textContent = 'ãƒ¢ãƒ‡ãƒ«èª­è¾¼å¤±æ•—: ' + (e.message||e);
        inferStartBtn.disabled = true;
      }
    }

    let inferTimer = null;
    async function runOnce(){
      if (!session || !idxToCell || !preview.videoWidth) return;
      const input = preprocessFromVideo(preview);
      const tensor = new ort.Tensor('float32', input, [1,3,IMG_H,IMG_W]);
      const outputs = await session.run({ images: tensor });
      const vals = Object.values(outputs);
      const cell = outputs.cell_logits ?? vals[0];
      const look = outputs.look_logits ?? vals[1];

      const cellLogits = Array.from(cell.data);
      const lookLogits = Array.from(look.data);

      const [cellIdx] = top1(cellLogits);
      const [lookIdx] = top1(lookLogits);

      const [gxC, gyC] = idxToCell[cellIdx] || ['?','?'];
      const [gxL, gyL] = idxToCell[lookIdx] || ['?','?'];

      const pCell = softmax(cellLogits)[cellIdx];
      const pLook = softmax(lookLogits)[lookIdx];

      overlayInfo.style.display = 'block';
      overlayInfo.innerHTML = `
        <div><b>ç¾åœ¨ã‚»ãƒ«</b>: #${cellIdx} (gx=${gxC}, gy=${gyC})  <span class="hint">p=${pCell.toFixed(3)}</span></div>
        <div><b>å‘ãå…ˆã‚»ãƒ«</b>: #${lookIdx} (gx=${gxL}, gy=${gyL})  <span class="hint">p=${pLook.toFixed(3)}</span></div>
      `;
    }
    function startInferLoop(){
      if (!session){ alert('ãƒ¢ãƒ‡ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“'); return; }
      if (!stream){ alert('å…ˆã«ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„'); return; }
      inferStatusEl.textContent = 'æ¨è«–ä¸­â€¦';
      inferStartBtn.disabled = true; inferStopBtn.disabled = false;
      inferTimer = setInterval(runOnce, 100); // ç´„10fps
    }
    function stopInferLoop(){
      inferStartBtn.disabled = false; inferStopBtn.disabled = true;
      inferStatusEl.textContent = 'åœæ­¢ä¸­';
      if (inferTimer){ clearInterval(inferTimer); inferTimer=null; }
    }
    inferStartBtn.addEventListener('click', startInferLoop);
    inferStopBtn.addEventListener('click', stopInferLoop);
    stopBtn.addEventListener('click', stopInferLoop);

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«è‡ªå‹•ãƒ­ãƒ¼ãƒ‰
    window.addEventListener('DOMContentLoaded', autoLoadModelAndMap);
  </script>
</body>
</html>
